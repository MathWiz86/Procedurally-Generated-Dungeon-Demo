/**************************************************************************************************/
/*!
\file   DungeonManager.cs
\author Craig Williams
\par    Last Updated
        2021-04-03

\brief
  A file containing implementation of a dungeon manager singleton, which handles creating a
  procedurally generated dugneon.

\par Bug List

\par References
  - https://vazgriz.com/119/procedurally-generated-dungeons/
  - https://github.com/vazgriz/DungeonGenerator
*/
/**************************************************************************************************/

using Delaunay;
using PCGDungeon.UnityEditor;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Security.Cryptography;
using UnityEditor;
using UnityEngine;

namespace PCGDungeon
{
  /************************************************************************************************/
  /// <summary>
  /// The overall manager for the procedurally generated dungeon. This handles all settings that
  /// manipulate how the dungeon will end up appearing.
  /// </summary>
  public class DungeonManager : MonoBehaviour
  {
    /// <summary>The random number generator dictating all processes of the generation.</summary>
    public static System.Random SystemRandomGenerator { get { return singleton ? singleton.RandomGenerator : null; } }

    /// <summary>The singleton instance for the dungeon manager.</summary>
    private static DungeonManager singleton;

    /// <summary>The maximum size of the dungeon, in (Width, Height).</summary>
    [Header("Dungeon Properties")]
    [SerializeField] private Vector2Int DungeonSize;
    /// <summary>The base prefab for a <see cref="DungeonRoomTile"/>.</summary>
    [SerializeField] private DungeonRoomTile BaseRoomTile;
    /// <summary>The base prefab for a <see cref="DungeonHallTile"/>.</summary>
    [SerializeField] private DungeonHallTile BaseHallTile;

    /// <summary>The parent object for spawning rooms onto as children.</summary>
    [Header("Room Properties")]
    [Space(20)]
    [SerializeField] private Transform RoomParentSpawn = null;
    /// <summary>The base prefab for a room object.</summary>
    [SerializeField] private DungeonRoom BaseRoom;
    /// <summary>The maximum number of rooms a dungeon can have.</summary>
    [SerializeField] [Min(0)] private int MaxRooms = 50;
    /// <summary>The maximum number of attempts to make at placing a room.</summary>
    [SerializeField] [Min(0)] private int MaxRoomAttempts = 100;
    /// <summary>The maximum size of a singular room, in (Width, Height).</summary>
    [SerializeField] private Vector2Int MaxRoomSize;
    /// <summary>The size of a room's border. This is how much hallway space to leave.</summary>
    [SerializeField] [Range(1, 5)] [ReadOnly(true)] private int RoomBorder = 1;
    
    /// <summary>The parent object for spawning hallways onto as children.</summary>
    [Header("Hallway Properties")]
    [Space(20)]
    [SerializeField] private Transform HallwayParentSpawn;
    /// <summary>The chance of readding a path to the hallway MST, making a loop.</summary>
    [SerializeField] [Range(0.0f, 1.0f)] private float LoopbackChance = 0.125f;

    /// <summary>A bool determining if a random seed is used or not for generation.</summary>
    [Header("Randomization Properties")]
    [Space(20)]
    [SerializeField] private bool NoRandomization = false;
    /// <summary>The seed to use when <see cref="NoRandomization"/> is checked.</summary>
    [SerializeField] private int ForcedSeed = 0;

    private DungeonTile[,] DungeonTiles = null;
    /// <summary>The list of all rooms generated by the dungeon.</summary>
    private List<DungeonRoom> DungeonRooms = new List<DungeonRoom>();
    /// <summary>The list of all hallways generated by the dungeon.</summary>
    private List<DungeonHallTile> DungeonHalls = new List<DungeonHallTile>();
    /// <summary>The random generator for content generation. We do not use Unity's functions in
    /// order to have control of the seed while in the editor.</summary>
    private System.Random RandomGenerator;
    /// <summary>The <see cref="Delaunay.Delaunay"/> Triangulation of the dungeon rooms.</summary>
    private Delaunay.Delaunay DelaunayTriangluation = null;
    /// <summary>The edges that make up the hallways, before pathfinding.</summary>
    private List<Edge> MSTEdges = new List<Edge>();

    /// <summary>A bool determining if a dungeon is in the process of generating.</summary>
    private bool generatingDungeon = false;
    /// <summary>A bool determining if a dungeon generates step by step.</summary>
    private bool generateSlow = false;
    /// <summary>The <see cref="Coroutine"/> for generating the dungeon.</summary>
    private Coroutine coGeneration = null;

#if UNITY_EDITOR
    /// <summary>A toggle for displaying the gizmos of the <see cref="DungeonRooms"/>.</summary>
    [Header("EDITOR ONLY PROPERTIES")]
    [Space(20)]
    [SerializeField] [InspectorFunction(nameof(GenerateDungeon), true)] private int GenerateNewDungeonBu;
    [SerializeField] private bool DisplayRoomGizmos = true;
    /// <summary>The color for the <see cref="DungeonRooms"/> gizmos.</summary>
    [SerializeField] private Color RoomGizmosColor = Color.red;
    /// <summary>A toggle for displaying the gizmos of the hallways.</summary>
    [SerializeField] private bool DisplayHallwayGizmos = false;
    /// <summary>The color for the hallway gizmos.</summary>
    [SerializeField] private Color HallwayGizmosColor = Color.blue;
    /// <summary>A toggle for displaying the <see cref="DelaunayTriangluation"/>.</summary>
    [SerializeField] private bool DisplayDelaunayGizmos = true;
    /// <summary>The color for the <see cref="DelaunayTriangluation"/> gizmos.</summary>
    [SerializeField] private Color DelaunayGizmosColor = Color.white;
    /// <summary>A toggle for displaying the gizmos of the <see cref="MSTEdges"/>.</summary>
    [SerializeField] private bool DisplayMSTGizmos = false;
    /// <summary>The color for the <see cref="MSTEdges"/> gizmos.</summary>
    [SerializeField] private Color MSTGizmosColor = Color.black;
#endif

    private void Awake()
    {
      // Declare this as a singleton manager.
      if (!singleton)
        singleton = this;
      else
        Destroy(this.gameObject);
    }

    private void Start()
    {
      GenerateDungeon();
    }

    /// <summary>
    /// A function to get the current dungeon's size.
    /// </summary>
    /// <returns>Returns the <see cref="DungeonSize"/>.</returns>
    public static Vector2Int GetDungeonSize()
    {
      return singleton ? singleton.DungeonSize : Vector2Int.zero;
    }

    /// <summary>
    /// A setter for the <see cref="DungeonSize"/>
    /// </summary>
    /// <param name="size">The new dungeon size.</param>
    public static void SetDungeonSize(Vector2Int size)
    {
      if (singleton && size.x >= 5 && size.y >= 5)
        singleton.DungeonSize = size;
    }

    /// <summary>
    /// A getter for the <see cref="DungeonSize"/>
    /// </summary>
    /// <returns>Returns the current size of the dungeon.</returns>
    public static Vector2Int GetMaxRoomSize()
    {
      return singleton ? singleton.MaxRoomSize : Vector2Int.zero;
    }

    /// <summary>
    /// A setter for the <see cref="MaxRoomSize"/>
    /// </summary>
    /// <param name="size">The new maximum size for rooms.</param>
    public static void SetMaxRoomSize(Vector2Int size)
    {
      if (singleton && size.x > 0 && size.y > 0)
        singleton.MaxRoomSize = size;
    }

    /// <summary>
    /// A setter for the <see cref="MaxRooms"/>
    /// </summary>
    /// <param name="rooms">The new max room count.</param>
    public static void SetMaxRooms(int rooms)
    {
      if (singleton && rooms > 0)
        singleton.MaxRooms = rooms;
    }

    /// <summary>
    /// A setter for the <see cref="MaxRoomAttempts"/>
    /// </summary>
    /// <param name="attempts">The new attempt count.</param>
    public static void SetMaxAttempts(int attempts)
    {
      if (singleton && attempts > 0)
        singleton.MaxRoomAttempts = attempts;
    }

    /// <summary>
    /// A setter for the <see cref="LoopbackChance"/>
    /// </summary>
    /// <param name="chance">The new loopback chance.</param>
    public static void SetLoopbackChance(float chance)
    {
      if (singleton)
        singleton.LoopbackChance = Mathf.Clamp(chance, 0, 1);
    }

    /// <summary>
    /// A setter for <see cref="NoRandomization"/>
    /// </summary>
    /// <param name="random">The new toggle for allowing randomness.</param>
    public static void SetAllowRandomness(bool random)
    {
      if (singleton)
        singleton.NoRandomization = !random;
    }

    /// <summary>
    /// A setter for the <see cref="ForcedSeed"/>
    /// </summary>
    /// <param name="seed">The new seed when there is no randomness.</param>
    public static void SetForcedSeed(int seed)
    {
      if (singleton)
        singleton.ForcedSeed = seed;
    }

    /// <summary>
    /// A setter for the <see cref="generateSlow"/>
    /// </summary>
    /// <param name="slow">The new toggle for generating step-by-step.</param>
    public static void SetSlowMode(bool slow)
    {
      if (singleton)
        singleton.generateSlow = slow;
    }

    /// <summary>
    /// a getter for <see cref="generatingDungeon"/>.
    /// </summary>
    /// <returns>Returns if the generator is in progress.</returns>
    public static bool GetIsGenerating()
    {
      return singleton ? singleton.generatingDungeon : false;
    }

    /// <summary>
    /// A helper function to check if a given index is within the dungeon map.
    /// </summary>
    /// <param name="index">The index to check.</param>
    /// <returns>Returns if the <paramref name="index"/> is valid.</returns>
    public static bool IsValidTileIndex(Vector2Int index)
    {
      if (singleton)
      {
        return index.x >= 0 && index.x < singleton.DungeonSize.x && index.y >= 0 && index.y < singleton.DungeonSize.y;
      }

      return false;
    }

    /// <summary>
    /// A helper function for getting the type of tile at a given index.
    /// </summary>
    /// <param name="index">The index of the tile to check.</param>
    /// <returns>Gets the <see cref="TileBasicType"/> at the given index.</returns>
    public static TileBasicType GetTileType(Vector2Int index)
    {
      // IsValidTileIndex already makes sure that the singleton is valid.
      if (IsValidTileIndex(index))
      {
        DungeonTile tile = singleton.DungeonTiles[index.x, index.y];
        return tile != null ? tile.BasicType : TileBasicType.Empty;
      }

      return TileBasicType.Empty;
    }

    /// <summary>
    /// A helper function for getting the <see cref="DungeonTile"/> at a given
    /// <paramref name="index"/>.
    /// </summary>
    /// <param name="index">The index of the <see cref="DungeonTile"/> to get.</param>
    /// <returns>Returns the <see cref="DungeonTile"/> at the <paramref name="index"/>.
    /// If the tile does not exist, returns null.</returns>
    public static DungeonTile GetDungeonTile(Vector2Int index)
    {
      if (IsValidTileIndex(index))
        return singleton.DungeonTiles[index.x, index.y];

      return null;
    }

    /// <summary>
    /// A function which adds a <see cref="DungeonTile"/> to the <see cref="DungeonManager"/>'s
    /// <see cref="DungeonTiles"/>.
    /// </summary>
    /// <param name="tile">The <see cref="DungeonTile"/> to add.</param>
    /// <returns>Returns if the <paramref name="tile"/> was added successfully.</returns>
    public static bool AddTileToDungeon(DungeonTile tile)
    {
      if (singleton && IsValidTileIndex(tile.TileIndex))
      {
        singleton.DungeonTiles[tile.TileIndex.x, tile.TileIndex.y] = tile;
        return true;
      }

      return false;
    }

    /// <summary>
    /// A function for generating out the entire dungeon.
    /// </summary>
    public static void GenerateNewDungeon()
    {
      if (singleton)
        singleton.GenerateDungeon();
    }

    /// <summary>
    /// The internal function for <see cref="GenerateNewDungeon"/>.
    /// </summary>
    private void GenerateDungeon()
    {
      if (!generatingDungeon)
      {
        if (coGeneration != null)
          StopCoroutine(coGeneration);

        generatingDungeon = true;

        if (generateSlow)
          coGeneration = StartCoroutine(HandleSlowDungeonGeneration());
        else
          coGeneration = StartCoroutine(HandleQuickDungeonGeneration());
      }
    }

    /// <summary>
    /// A <see cref="Coroutine"/> for generating the dungeon quickly.
    /// </summary>
    /// <returns>Returns an <see cref="IEnumerator"/> for use in <see cref="Coroutine"/>s.</returns>
    private IEnumerator HandleQuickDungeonGeneration()
    {
      // Regenerate with a new seed.
      RandomGenerator = NoRandomization ? new System.Random(ForcedSeed) : new System.Random();

      CleanDungeon(); // Clean out the dungeon.
      DemoManager.CleanTiles(); // Clean out the demo.
      DemoManager.InitializeDemoCamera(); // Initialize the camera.
      GenerateRooms(); // Generate the rooms.
      CreateDelaunayTriangulation(); // Triangulate the map.
      GenerateMinimumSpanningTree(); // Generate the MST for the hallways.
      GenerateHallways(); // Generate the hallways.
      GenerateHallwayWalls(); // Generate the walls of the hallways first.
      GenerateRoomWalls(); // Generate the walls of the rooms second.
      GenerateRoomEnvironments(); // Generate the environments.
      GenerateRivers(); // Generate the rivers.
      GenerateTileDecor(); // Generate the decor.
      DemoManager.CreateAllTiles(); // Display the demo.

      yield return new WaitForSecondsRealtime(0.01f);
      MeshGeneration.GenerateMesh(gameObject);

      if (DungeonRooms.Count > 0)
        DemoManager.InitializeDemoController(DungeonRooms[0]);

      generatingDungeon = false;
      yield return null;
    }

    /// <summary>
    /// A <see cref="Coroutine"/> for generating the dungeon step by step.
    /// </summary>
    /// <returns>Returns an <see cref="IEnumerator"/> for use in <see cref="Coroutine"/>s.</returns>
    private IEnumerator HandleSlowDungeonGeneration()
    {
      DemoManager.ForceHUDDisplay(false);
      // Regenerate with a new seed.
      RandomGenerator = NoRandomization ? new System.Random(ForcedSeed) : new System.Random();

      CleanDungeon(); // Clean out the dungeon.
      DemoManager.CleanTiles(); // Clean out the demo.
      DemoManager.InitializeDemoCamera(); // Initialize the camera.

      yield return SlowGenerateRooms(); // Generate the rooms.

      CreateDelaunayTriangulation(); // Triangulate the map.
      GenerateMinimumSpanningTree(); // Generate the MST for the hallways.

      yield return SlowGenerateHallways(); // Generate the hallways.

      yield return SlowGenerateHallwayWalls(); // Generate the walls of the hallways first.

      yield return SlowGenerateRoomWalls(); // Generate the walls of the rooms second.

      yield return SlowGenerateRoomEnvironments(); // Generate the environments.

      yield return SlowGenerateRivers(); // Generate the rivers.

      yield return SlowGenerateTileDecor(); // Generate the decor.

      //DemoManager.CreateAllTiles(); // Display the demo.

      yield return new WaitForSecondsRealtime(0.01f);
      MeshGeneration.GenerateMesh(gameObject);

      if (DungeonRooms.Count > 0)
        DemoManager.InitializeDemoController(DungeonRooms[0]);

      DemoManager.ForceHUDDisplay(true);
      generatingDungeon = false;
      yield return null;
    }

    /// <summary>
    /// A function for cleaning out and destroying a previous dungeon.
    /// </summary>
    private void CleanDungeon()
    {
      // Wipe out any older dungeon rooms.
      int RoomCount = DungeonRooms.Count;
      int HallCount = DungeonHalls.Count;

#if UNITY_EDITOR
      if (!EditorApplication.isPlayingOrWillChangePlaymode)
      {
        for (int i = 0; i < RoomCount; i++)
          DestroyImmediate(DungeonRooms[i].gameObject);
        for (int i = 0; i < HallCount; i++)
          DestroyImmediate(DungeonHalls[i].gameObject);
      }
      else
      {
        for (int i = 0; i < RoomCount; i++)
          Destroy(DungeonRooms[i].gameObject);
        for (int i = 0; i < HallCount; i++)
          Destroy(DungeonHalls[i].gameObject);
      }
#else
      for (int i = 0; i < RoomCount; i++)
        Destroy(DungeonRooms[i].gameObject);
      for (int i = 0; i < HallCount; i++)
        Destroy(DungeonHalls[i].gameObject);
#endif
      DungeonRooms.Clear();
      DungeonHalls.Clear();
      MSTEdges.Clear();
      MeshFilter MeshFilter = GetComponent<MeshFilter>();
      if (MeshFilter)
        DestroyImmediate(MeshFilter.sharedMesh);

      // Reinitialize the tile types, resulting in all being empty at the start.
      DungeonTiles = new DungeonTile[DungeonSize.x, DungeonSize.y];

      HallwayPather.InitializePather(DungeonSize); // Initialize the pather.
    }

    /// <summary>
    /// A function for generating all the rooms in a random fashion.
    /// </summary>
    private void GenerateRooms()
    {
      // Borders are centered, so we offset by the wanted border.
      Vector2Int BorderLocationChange = new Vector2Int(-RoomBorder, -RoomBorder);
      // Double the room border, since borders are centered.
      Vector2Int BorderSizeChange = new Vector2Int(RoomBorder * 2, RoomBorder * 2);

      // Attempt to place as many rooms as possible into the grid.
      for (int i = 0; i < MaxRoomAttempts; i++)
      {
        // Get a random location and size, within bounds, for the current room.
        Vector2Int roomLocation = new Vector2Int(RandomGenerator.Next(0, DungeonSize.x), RandomGenerator.Next(0, DungeonSize.y));
        Vector2Int roomSize = new Vector2Int(RandomGenerator.Next(1, MaxRoomSize.x + 1), RandomGenerator.Next(1, MaxRoomSize.y + 1));

        // Create the bounds rect for this room for calculations.
        RectInt roomBounds = new RectInt(roomLocation, roomSize);

        // Make sure we have not gone past bounds. As pivots are corners, going below 0 is impossible.
        if (roomBounds.xMax >= DungeonSize.x || roomBounds.yMax >= DungeonSize.y)
          continue;

        // Iterate through all currently created rooms and make sure the new room overlaps none.
        bool validRoom = true;
        int CurrentRoomCount = DungeonRooms.Count;
        RectInt Border = new RectInt(roomLocation + BorderLocationChange, roomSize + BorderSizeChange);
        for (int j = 0; j < CurrentRoomCount; j++)
        {
          if (DungeonRooms[j].CheckOverlap(Border))
          {
            validRoom = false;
            break;
          }
        }

        // If the room is valid, create it.
        if (validRoom)
        {
          DungeonRoom room = Instantiate(BaseRoom, new Vector3(roomLocation.x, 0, roomLocation.y), Quaternion.identity, RoomParentSpawn);
          room.InitializeBounds(roomBounds); // Initialize the bounds.
          room.CreateRoomTiles(BaseRoomTile); // Create the individual tiles of the room.
          DungeonRooms.Add(room);
          

          // Iterate through all positions within the rect. These are all room tiles.
         // foreach (Vector2Int position in roomBounds.allPositionsWithin)
           // DungeonTiles[position.x, position.y] = TileBasicType.Room;

          // If we have hit the limit on rooms, stop.
          if (DungeonRooms.Count >= MaxRooms)
            break;
        }
      }
    }

    /// <summary>
    /// A <see cref="Coroutine"/> for generating all the rooms in a random fashion.
    /// </summary>
    /// <returns>Returns an <see cref="IEnumerator"/> for use in <see cref="Coroutine"/>s.</returns>
    private IEnumerator SlowGenerateRooms()
    {
      // Borders are centered, so we offset by the wanted border.
      Vector2Int BorderLocationChange = new Vector2Int(-RoomBorder, -RoomBorder);
      // Double the room border, since borders are centered.
      Vector2Int BorderSizeChange = new Vector2Int(RoomBorder * 2, RoomBorder * 2);

      // Attempt to place as many rooms as possible into the grid.
      for (int i = 0; i < MaxRoomAttempts; i++)
      {
        // Get a random location and size, within bounds, for the current room.
        Vector2Int roomLocation = new Vector2Int(RandomGenerator.Next(0, DungeonSize.x), RandomGenerator.Next(0, DungeonSize.y));
        Vector2Int roomSize = new Vector2Int(RandomGenerator.Next(1, MaxRoomSize.x + 1), RandomGenerator.Next(1, MaxRoomSize.y + 1));

        // Create the bounds rect for this room for calculations.
        RectInt roomBounds = new RectInt(roomLocation, roomSize);

        // Make sure we have not gone past bounds. As pivots are corners, going below 0 is impossible.
        if (roomBounds.xMax >= DungeonSize.x || roomBounds.yMax >= DungeonSize.y)
          continue;

        // Iterate through all currently created rooms and make sure the new room overlaps none.
        bool validRoom = true;
        int CurrentRoomCount = DungeonRooms.Count;
        RectInt Border = new RectInt(roomLocation + BorderLocationChange, roomSize + BorderSizeChange);
        for (int j = 0; j < CurrentRoomCount; j++)
        {
          if (DungeonRooms[j].CheckOverlap(Border))
          {
            validRoom = false;
            break;
          }
        }

        // If the room is valid, create it.
        if (validRoom)
        {
          DungeonRoom room = Instantiate(BaseRoom, new Vector3(roomLocation.x, 0, roomLocation.y), Quaternion.identity, RoomParentSpawn);
          room.InitializeBounds(roomBounds); // Initialize the bounds.
          room.CreateRoomTiles(BaseRoomTile); // Create the individual tiles of the room.
          DungeonRooms.Add(room);

          // SLOW GENERATION
          foreach (Vector2Int index in roomBounds.allPositionsWithin)
            DemoManager.CreateSingleTile(index);
          yield return null;

          // If we have hit the limit on rooms, stop.
          if (DungeonRooms.Count >= MaxRooms)
            break;
        }
      }
    }

    /// <summary>
    /// A function for creating a triangulated map via the Delaunay method. This is then used for
    /// generating random hallways.
    /// </summary>
    private void CreateDelaunayTriangulation()
    {
      List<Vertex> vertices = new List<Vertex>(); // A list of vertices.

      int roomCount = DungeonRooms.Count; // Get the number of rooms.
                                          // Add the vertices of every room.
      for (int i = 0; i < roomCount; i++)
      {
        DungeonRoom room = DungeonRooms[i];
        Vector2 temp = (room.GetPosition() + (Vector2)room.GetSize() / 2);
        vertices.Add(new Vertex<DungeonRoom>(new Vector3(temp.x, temp.y, 0), room));
      }
      // Create the final triangulation.
      DelaunayTriangluation = Delaunay.Delaunay.CreateDelaunayTriangulation(vertices);
    }

    /// <summary>
    /// A function to create a minimum spanning tree via Prim's Algorithm. This will be used to
    /// create the edges that form hallways.
    /// </summary>
    private void GenerateMinimumSpanningTree()
    {
      // Get a minimum spanning tree from the triangulation, as a base for the hallways.
      HashSet<Edge> mst = DelaunayTriangluation.CreateMinimumSpanningTree();

      // If there's a loopback chance, we need to add back a few hallways.
      if (LoopbackChance > 0.0f)
      {
        // Get a set of all edges that were not included into the tree.
        HashSet<Edge> ExtraEdges = new HashSet<Edge>(DelaunayTriangluation.Edges);
        ExtraEdges.ExceptWith(mst);

        // Iterate through the set.
        foreach (Edge edge in ExtraEdges)
        {
          // If the chance is hit, add back the excluded edge.
          if (RandomGenerator.NextDouble() < LoopbackChance)
            mst.Add(edge);
        }
      }
      MSTEdges = mst.ToList(); // Convert to a list afterwards.
    }

    /// <summary>
    /// A function to create <see cref="DungeonHallTile"/>s, based on the A* Algorithm
    /// via the <see cref="HallwayPather"/>.
    /// </summary>
    private void GenerateHallways()
    {
      int edgeCount = MSTEdges.Count; // Get the number of edges.

      // Iterate and pathfind for all hallway edges.
      for (int i = 0; i < edgeCount; i++)
      {
        Edge edge = MSTEdges[i];

        // Get the rooms attached to the edge's vertices.
        DungeonRoom startRoom = (edge.U as Vertex<DungeonRoom>).Item;
        DungeonRoom endRoom = (edge.V as Vertex<DungeonRoom>).Item;

        // Get the centers of each room.
        Vector2 startCenter = startRoom.GetBounds().center;
        Vector2 endCenter = endRoom.GetBounds().center;

        // Get the coordinates of the start and end tiles, rounded to the grid.
        Vector2Int startPos = new Vector2Int((int)startCenter.x, (int)startCenter.y);
        Vector2Int endPos = new Vector2Int((int)endCenter.x, (int)endCenter.y);

        // Determine a path through the grid.
        List<Vector2Int> path = HallwayPather.FindPath(startPos, endPos);

        // Make sure the path is valid before placing hallway tiles.
        if (path != null)
        {
          int pathCount = path.Count;

          for (int j = 0; j < pathCount; j++)
          {
            Vector2Int currentIndex = path[j];

            // Only place hallway tiles on empty tiles.
            if (GetTileType(currentIndex) == TileBasicType.Empty)
            {
              DungeonHallTile tile = Instantiate(BaseHallTile, new Vector3(currentIndex.x, 0, currentIndex.y), Quaternion.identity, HallwayParentSpawn);
              tile.SetIndex(currentIndex);
              DungeonTiles[currentIndex.x, currentIndex.y] = tile;
              DungeonHalls.Add(tile);
            }
          }
        }
      }
    }

    /// <summary>
    /// A <see cref="Coroutine"/> to create <see cref="DungeonHallTile"/>s, based on the A*
    /// Algorithm via the <see cref="HallwayPather"/>.
    /// </summary>
    /// <returns>Returns an <see cref="IEnumerator"/> for use in <see cref="Coroutine"/>s.</returns>
    private IEnumerator SlowGenerateHallways()
    {
      int edgeCount = MSTEdges.Count; // Get the number of edges.

      // Iterate and pathfind for all hallway edges.
      for (int i = 0; i < edgeCount; i++)
      {
        Edge edge = MSTEdges[i];

        // Get the rooms attached to the edge's vertices.
        DungeonRoom startRoom = (edge.U as Vertex<DungeonRoom>).Item;
        DungeonRoom endRoom = (edge.V as Vertex<DungeonRoom>).Item;

        // Get the centers of each room.
        Vector2 startCenter = startRoom.GetBounds().center;
        Vector2 endCenter = endRoom.GetBounds().center;

        // Get the coordinates of the start and end tiles, rounded to the grid.
        Vector2Int startPos = new Vector2Int((int)startCenter.x, (int)startCenter.y);
        Vector2Int endPos = new Vector2Int((int)endCenter.x, (int)endCenter.y);

        // Determine a path through the grid.
        List<Vector2Int> path = HallwayPather.FindPath(startPos, endPos);

        // Make sure the path is valid before placing hallway tiles.
        if (path != null)
        {
          int pathCount = path.Count;

          for (int j = 0; j < pathCount; j++)
          {
            Vector2Int currentIndex = path[j];

            // Only place hallway tiles on empty tiles.
            if (GetTileType(currentIndex) == TileBasicType.Empty)
            {
              DungeonHallTile tile = Instantiate(BaseHallTile, new Vector3(currentIndex.x, 0, currentIndex.y), Quaternion.identity, HallwayParentSpawn);
              tile.SetIndex(currentIndex);
              DungeonTiles[currentIndex.x, currentIndex.y] = tile;
              DungeonHalls.Add(tile);

              // SLOW GENERATION
              DemoManager.CreateSingleTile(currentIndex);
              yield return null;
            }
          }
        }
      }
    }

    /// <summary>
    /// A function to generate the four <see cref="DungeonWall"/>s of each
    /// <see cref="DungeonHallTile"/>.
    /// </summary>
    private void GenerateHallwayWalls()
    {
      // Calculate the base walls for every dungeon hall tile.
      int hallCount = DungeonHalls.Count;
      for (int i = 0; i < hallCount; i++)
        DungeonHalls[i].CalculateBaseWalls();
    }

    /// <summary>
    /// A <see cref="Coroutine"/> to generate the four <see cref="DungeonWall"/>s of each
    /// <see cref="DungeonHallTile"/>.
    /// </summary>
    /// <returns>Returns an <see cref="IEnumerator"/> for use in <see cref="Coroutine"/>s.</returns>
    private IEnumerator SlowGenerateHallwayWalls()
    {
      // Calculate the base walls for every dungeon hall tile.
      int hallCount = DungeonHalls.Count;
      for (int i = 0; i < hallCount; i++)
      {
        DungeonHalls[i].CalculateBaseWalls();

        // SLOW GENERATION
        DemoManager.UpdateSingleTile(DungeonHalls[i].TileIndex);
        yield return null;
      }
        
    }

    /// <summary>
    /// A function to generate the four <see cref="DungeonWall"/>s of each
    /// <see cref="DungeonRoomTile"/>.
    /// </summary>
    private void GenerateRoomWalls()
    {
      // Calculate the base walls for every dungeon room tile.
      int roomCount = DungeonRooms.Count;
      for (int i = 0; i < roomCount; i++)
        DungeonRooms[i].GenerateRoomTileWalls();
    }

    /// <summary>
    /// A <see cref="Coroutine"/> to generate the four <see cref="DungeonWall"/>s of each
    /// <see cref="DungeonRoomTile"/>.
    /// </summary>
    /// <returns>Returns an <see cref="IEnumerator"/> for use in <see cref="Coroutine"/>s.</returns>
    private IEnumerator SlowGenerateRoomWalls()
    {
      // Calculate the base walls for every dungeon room tile.
      int roomCount = DungeonRooms.Count;
      for (int i = 0; i < roomCount; i++)
      {
        DungeonRooms[i].GenerateRoomTileWalls();

        RectInt bounds = DungeonRooms[i].GetBounds();

        // SLOW GENERATION
        foreach (Vector2Int index in bounds.allPositionsWithin)
        {
          DemoManager.UpdateSingleTile(index);
          yield return null;
        }
      }
    }

    /// <summary>
    /// A function to generate the <see cref="TileEnvironmentType"/> of every tile in a
    /// <see cref="DungeonRoom"/>, while spreading to the nearby <see cref="DungeonHallTile"/>s.
    /// </summary>
    private void GenerateRoomEnvironments()
    {
      // Generate the environments for each room.
      int roomCount = DungeonRooms.Count;
      for (int i = 0; i < roomCount; i++)
        DungeonRooms[i].GenerateEnvironment();
    }

    /// <summary>
    /// A <see cref="Coroutine"/> to generate the <see cref="TileEnvironmentType"/> of every tile in
    /// a <see cref="DungeonRoom"/>, while spreading to the nearby <see cref="DungeonHallTile"/>s.
    /// </summary>
    /// <returns>Returns an <see cref="IEnumerator"/> for use in <see cref="Coroutine"/>s.</returns>
    private IEnumerator SlowGenerateRoomEnvironments()
    {
      // Generate the environments for each room.
      int roomCount = DungeonRooms.Count;
      for (int i = 0; i < roomCount; i++)
      {
        DungeonRooms[i].GenerateEnvironment();

        RectInt bounds = DungeonRooms[i].GetBounds();

        // SLOW GENERATION
        foreach (Vector2Int index in bounds.allPositionsWithin)
          DemoManager.UpdateSingleTile(index);
        yield return null;
      }
        
    }

    /// <summary>
    /// A function to generate rivers by placing <see cref="TileEnvironmentType.Water"/>
    /// in straight lines in each <see cref="DungeonRoom"/>.
    /// </summary>
    private void GenerateRivers()
    {
      // In each room, generate the rivers.
      int roomCount = DungeonRooms.Count;
      for (int i = 0; i < roomCount; i++)
        DungeonRooms[i].GenerateRivers();
    }

    /// <summary>
    /// A <see cref="Coroutine"/> to generate rivers by placing
    /// <see cref="TileEnvironmentType.Water"/> in straight lines in each <see cref="DungeonRoom"/>.
    /// </summary>
    /// <returns>Returns an <see cref="IEnumerator"/> for use in <see cref="Coroutine"/>s.</returns>
    private IEnumerator SlowGenerateRivers()
    {
      // In each room, generate the rivers.
      int roomCount = DungeonRooms.Count;
      for (int i = 0; i < roomCount; i++)
        yield return DungeonRooms[i].SlowGenerateRivers(); 
    }

    /// <summary>
    /// A function to generate the <see cref="TileDecorType"/> of every tile in the dungeon.
    /// </summary>
    private void GenerateTileDecor()
    {
      // Iterate through every row and column.
      for (int row = 0; row < DungeonSize.x; row++)
      {
        for (int col = 0; col < DungeonSize.y; col++)
        {
          DungeonTile tile = DungeonTiles[row, col]; // Get the current tile.

          // If the tile exists, get its decor type, based on its environment.
          if (tile && tile.DecorType == TileDecorType.None)// && tile.BasicType == TileBasicType.Room)
            tile.SetDecorType(DungeonDecorator.GetRandomEnvironmentDecor(tile.EnvironmentType));
        }
      }
    }

    /// <summary>
    /// A <see cref="Coroutine"/> to generate the <see cref="TileDecorType"/> of every tile in
    /// the dungeon.
    /// </summary>
    /// <returns>Returns an <see cref="IEnumerator"/> for use in <see cref="Coroutine"/>s.</returns>
    private IEnumerator SlowGenerateTileDecor()
    {
      // Iterate through every row and column.
      for (int row = 0; row < DungeonSize.x; row++)
      {
        for (int col = 0; col < DungeonSize.y; col++)
        {
          DungeonTile tile = DungeonTiles[row, col]; // Get the current tile.

          // If the tile exists, get its decor type, based on its environment.
          if (tile && tile.DecorType == TileDecorType.None)
          {
            tile.SetDecorType(DungeonDecorator.GetRandomEnvironmentDecor(tile.EnvironmentType));
            DemoManager.UpdateSingleTile(tile.TileIndex);
            yield return null;
          }
        }
      }
    }

#if UNITY_EDITOR
    private void OnDrawGizmos()
    {
      DrawRoomGizmos();
      DrawHallwayGizmos();
      DrawDelaunayGizmos();
      DrawMSTGizmos();
    }

    private void DrawRoomGizmos()
    {
      if (DisplayRoomGizmos)
      {
        Gizmos.color = RoomGizmosColor;

        int roomCount = DungeonRooms.Count;

        for (int i = 0; i < roomCount; i++)
        {
          DungeonRoom room = DungeonRooms[i];
          RectInt roomBounds = room.GetBounds();
          Gizmos.DrawCube(new Vector3(roomBounds.center.x, 0, roomBounds.center.y), new Vector3(roomBounds.size.x, 1, roomBounds.size.y));
        }
      }
    }

    private void DrawDelaunayGizmos()
    {
      if (DisplayDelaunayGizmos && DelaunayTriangluation != null)
      {
        Gizmos.color = DelaunayGizmosColor;
        int edgeCount = DelaunayTriangluation.Edges.Count;

        for (int i = 0; i < edgeCount; i++)
        {
          Edge edge = DelaunayTriangluation.Edges[i];
          Vector3 trueU = new Vector3(edge.U.Position.X, 0, edge.U.Position.Y);
          Vector3 trueV = new Vector3(edge.V.Position.X, 0, edge.V.Position.Y);
          Gizmos.DrawLine(trueU, trueV);
        }
      }
    }

    private void DrawMSTGizmos()
    {
      if (DisplayMSTGizmos && MSTEdges.Count > 0)
      {
        Gizmos.color = MSTGizmosColor;
        int edgeCount = MSTEdges.Count;

        for (int i = 0; i < edgeCount; i++)
        {
          Edge edge = MSTEdges[i];
          Vector3 trueU = new Vector3(edge.U.Position.X, 0, edge.U.Position.Y);
          Vector3 trueV = new Vector3(edge.V.Position.X, 0, edge.V.Position.Y);
          Gizmos.DrawLine(trueU, trueV);
        }
      }
    }

    private void DrawHallwayGizmos()
    {
      Gizmos.color = HallwayGizmosColor;

      if (DisplayHallwayGizmos && DungeonTiles != null)
      {
        try
        {
          for (int row = 0; row < DungeonSize.x; row++)
          {
            for (int col = 0; col < DungeonSize.y; col++)
            {
              TileBasicType type = GetTileType(new Vector2Int(row, col));

              if (type == TileBasicType.Hallway)
                Gizmos.DrawCube(new Vector3(row + 0.5f, 0, col + 0.5f), new Vector3(1, 1, 1));
            }
          }
        }
        catch
        {
          // Only happens when changing dungeon size in editor.
        }
      }
    }
#endif
  }
  /************************************************************************************************/
}